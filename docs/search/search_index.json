{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The purpose of Policy Machine Core project is to provide a bare bones library for NGAC. This library includes interfaces to interact with NGAC components,simple implementations of those interfaces, and algorithms to query the state of a graph. This is a great place to start experimenting with NGAC and different policy configurations.","title":"Introduction"},{"location":"contact/","text":"Contact Us David Ferraiolo - david.ferraiolo@nist.gov (Group Manager) Serban Gavrila - serban.gavrila@nist.gov (Developer) Gopi Katwala - gopi.katwala@nist.gov (Developer) Joshua Roberts - joshua.roberts@nist.gov (Developer)","title":"Contact Us"},{"location":"contact/#contact-us","text":"David Ferraiolo - david.ferraiolo@nist.gov (Group Manager) Serban Gavrila - serban.gavrila@nist.gov (Developer) Gopi Katwala - gopi.katwala@nist.gov (Developer) Joshua Roberts - joshua.roberts@nist.gov (Developer)","title":"Contact Us"},{"location":"examples/","text":"Serialization Graph There are two ways to serialize a graph. This first is to serialize it into json. The second is a command like structure that is easier to read than json. JSON Graph graph = new MemGraph(); --- String json = GraphSerializer.toJson(graph); Deserialize a json string to a graph. Graph graph = GraphSerializer.fromJson(new MemGraph(), json); Readable Format There are three primary commands for the readable format: node , assign , and assoc . node PC pc1 node OA oa1 node UA ua1 node O o1 node U u1 assign OA:oa1 PC:pc1 assign UA:ua1 PC:pc1 assign O:o1 OA:oa1 assign U:u1 UA:ua1 assoc UA:ua1 OA:oa1 [read,write] String serialize = GraphSerializer.serialize(graph); Graph deSerialize = GraphSerializer.deserialize(graph); Prohibitions Serialize a ProhibitionDAO into a json string. ProhibitionsDAO dao = new MemProhibitionsDAO(); --- String json = ProhibitionsSerializer.toJson(dao); Deserialize a json string to a ProhibitionsDAO. ProhibitionsDAO deDao = ProhibitionsSerializer.fromJson(new MemProhibitionsDAO(), json); Bank Teller Graph configuration summary Users: u1, u2 An object o1 Two policy classes: RBAC and Branches RBAC o1 is assigned to accounts u1 is a Teller that has read and write permissions on accounts u2 is an Auditor that has read permissions on accounts Branches u1 and u2 are both assigned to the Branch 1 user attribute o1 is assigned to the Branch 1 object attribute the Branch 1 user attribute has read and write permissions on the Branch 1 object attribute Access control state u1 can read and write o1 u2 can read o1 Code Wakthrough // 1. Create a new Graph instance. For this example, we'll use the `MemGraph` which is an in memory implementation of the Graph interface. Graph graph = new MemGraph(); // 2. Create the user nodes `u1` and `u2`. Node user1Node = graph.createNode(rand.nextLong(), \"u1\", U, null); Node user2Node = graph.createNode(rand.nextLong(), \"u2\", U, null); // 3. Create the object, `o1` that will be the target of the access queries. Node objectNode = graph.createNode(rand.nextLong(), \"o1\", O, null); // 4. Create the `RBAC` policy class node. Node rbacNode = graph.createNode(rand.nextLong(), \"RBAC\", PC, null); // 5. Create an object attribute for the `Accounts`. Node accountsNode = graph.createNode(rand.nextLong(), \"Accounts\", OA, null); // 6. Create the `Teller` and `Auditor` user attributes. Node tellerNode = graph.createNode(rand.nextLong(), \"Teller\", UA, null); Node auditorNode = graph.createNode(rand.nextLong(), \"Auditor\", UA, null); // 7. Assign the `Accounts` object attribute to the `RBAC` policy class node. graph.assign(accountsNode.getID(), rbacNode.getID()); // 8. Assign the object, `o1`, to the `Accounts` object attribute. graph.assign(objectNode.getID(), accountsNode.getID()); // 9. Assign `u1` to the `Teller` user attribute and `u2` to the `Auditor` user attribute. graph.assign(user1Node.getID(), tellerNode.getID()); graph.assign(user2Node.getID(), auditorNode.getID()); // 10. Create the associations for `Teller` and `Auditor` on `Account` in RBAC. `Teller` has read and write permissions, while `Auditor` just has read permissions. graph.associate(tellerNode.getID(), accountsNode.getID(), new HashSet<>(Arrays.asList(\"r\", \"w\"))); graph.associate(auditorNode.getID(), accountsNode.getID(), new HashSet<>(Arrays.asList(\"r\"))); // 11. Create the `Branches` policy class. Node branchesNode = graph.createNode(rand.nextLong(), \"branches\", PC, null); // 12. Create an object attribute for `Branch 1`. Node branch1OANode = graph.createNode(rand.nextLong(), \"branch 1\", OA, null); // 13. Assign the branch 1 OA to the branches PC graph.assign(branch1OANode.getID(), branchesNode.getID()); // 14. Create the `Branch 1` user attribute Node branches1UANode = graph.createNode(rand.nextLong(), \"branch 1\", UA, null); // 15. Assign the object, `o1`, to the `Branch 1` object attribute graph.assign(objectNode.getID(), branch1OANode.getID()); // 16. Assign the users, `u1` and `u2`, to the branch 1 user attribute graph.assign(user1Node.getID(), branches1UANode.getID()); graph.assign(user2Node.getID(), branches1UANode.getID()); // 17. Create an association between the `branch 1` user attribute and the `branch 1` object attribute. //This will give both users read and write on `o1` under the `branches` policy class. graph.associate(branches1UANode.getID(), branch1OANode.getID(), new HashSet<>(Arrays.asList(\"r\", \"w\"))); To make access decisions: // 18. Test the configuration using the `PReviewDecider` implementation of the `Decider` interface. //The constructor for a `PReviewDecider` receives the graph we created and a list of prohibitions. //Since no prohibitions are used in this example, we'll pass null. Decider decider = new PReviewDecider(graph); // 19. Check that `u1` has read and write permissions on `o1`. Set<String> permissions = decider.listPermissions(user1Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // 20. Check that `u1` has read permissions on `o1`. permissions = decider.listPermissions(user2Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\")); Visualization Below is a visual representation of the graph created in the bank teller example. Employee Record Example configuration summary One policy class Users: bob, alice, charlie The objects are bob's and alice's name, salary, and ssn. All users are assigned to the Staff user attribute The Staff user attribute has read permissions on Public Info, which in this case is names. Charlie has the HR attribute HR has read and write permissions on Salaries and SSNs Bob and Alice have the Grp1Mgr and Grp2Mgr attributes, respectively Grp1Mgr and Grp2Mgr have read permissions on Grp1Salaries and Grp2Salaries, respectively Bob and Alice have read and write permissions on their name and ssn, and read permissions on their salaries. Access control state Alice can read and write her name and SSN, and read her salary, and the salaries of those in Group 2. Bob can read and write his name and SSN, and read his salary, and salaries of those in Group 1. Charlie can read and write all salaries and SSNs, and read all names. Graph graph = new MemGraph(); // create nodes // object attributes Node salariesNode = graph.createNode(rand.nextLong(), \"Salaries\", OA, null); Node ssnsNode = graph.createNode(rand.nextLong(), \"SSNs\", OA, null); Node grp1SalariesNode = graph.createNode(rand.nextLong(), \"Grp1 Salaries\", OA, null); Node grp2SalariesNode = graph.createNode(rand.nextLong(), \"Grp2 Salaries\", OA, null); Node publicNode = graph.createNode(rand.nextLong(), \"Public Info\", OA, null); Node bobRecNode = graph.createNode(rand.nextLong(), \"Bob Record\", OA, null); Node bobRNode = graph.createNode(rand.nextLong(), \"Bob r\", OA, null); Node bobRWNode = graph.createNode(rand.nextLong(), \"Bob r/w\", OA, null); Node aliceRecNode = graph.createNode(rand.nextLong(), \"Alice Record\", OA, null); Node aliceRNode = graph.createNode(rand.nextLong(), \"Alice r\", OA, null); Node aliceRWNode = graph.createNode(rand.nextLong(), \"Alice r/w\", OA, null); // objects for bob's name, salary, and ssn Node bobNameNode = graph.createNode(rand.nextLong(), \"bob name\", O, null); Node bobSalaryNode = graph.createNode(rand.nextLong(), \"bob salary\", O, null); Node bobSSNNode = graph.createNode(rand.nextLong(), \"bob ssn\", O, null); // objects for alice's name, salary, and ssn Node aliceNameNode = graph.createNode(rand.nextLong(), \"alice name\", O, null); Node aliceSalaryNode = graph.createNode(rand.nextLong(), \"alice salary\", O, null); Node aliceSSNNode = graph.createNode(rand.nextLong(), \"alice ssn\", O, null); // user attributes Node hrNode = graph.createNode(rand.nextLong(), \"HR\", UA, null); Node grp1MgrNode = graph.createNode(rand.nextLong(), \"Grp1Mgr\", UA, null); Node grp2MgrNode = graph.createNode(rand.nextLong(), \"Grp2Mgr\", UA, null); Node staffNode = graph.createNode(rand.nextLong(), \"Staff\", UA, null); Node bobUANode = graph.createNode(rand.nextLong(), \"Bob\", UA, null); Node aliceUANode = graph.createNode(rand.nextLong(), \"Alice\", UA, null); // users Node bobNode = graph.createNode(rand.nextLong(), \"bob\", U, null); Node aliceNode = graph.createNode(rand.nextLong(), \"alice\", U, null); Node charlieNode = graph.createNode(rand.nextLong(), \"charlie\", U, null); // policy class Node pcNode = graph.createNode(rand.nextLong(), \"Employee Records\", PC, null); // assignments // assign users to user attributes graph.assign(charlieNode.getID(), hrNode.getID()); graph.assign(bobNode.getID(), grp1MgrNode.getID()); graph.assign(aliceNode.getID(), grp2MgrNode.getID()); graph.assign(charlieNode.getID(), staffNode.getID()); graph.assign(bobNode.getID(), staffNode.getID()); graph.assign(aliceNode.getID(), staffNode.getID()); graph.assign(bobNode.getID(), bobUANode.getID()); graph.assign(aliceNode.getID(), aliceUANode.getID()); // assign objects to object attributes // salary objects graph.assign(bobSalaryNode.getID(), salariesNode.getID()); graph.assign(bobSalaryNode.getID(), grp1SalariesNode.getID()); graph.assign(bobSalaryNode.getID(), bobRNode.getID()); graph.assign(aliceSalaryNode.getID(), salariesNode.getID()); graph.assign(aliceSalaryNode.getID(), grp2SalariesNode.getID()); graph.assign(aliceSalaryNode.getID(), aliceRNode.getID()); // ssn objects graph.assign(bobSSNNode.getID(), ssnsNode.getID()); graph.assign(bobSSNNode.getID(), bobRWNode.getID()); graph.assign(aliceSSNNode.getID(), aliceNode.getID()); graph.assign(aliceSSNNode.getID(), aliceRWNode.getID()); // name objects graph.assign(bobNameNode.getID(), publicNode.getID()); graph.assign(bobNameNode.getID(), bobRWNode.getID()); graph.assign(aliceNameNode.getID(), publicNode.getID()); graph.assign(aliceNameNode.getID(), aliceRWNode.getID()); // bob and alice r/w containers to their records graph.assign(bobRNode.getID(), bobRecNode.getID()); graph.assign(bobRWNode.getID(), bobRecNode.getID()); graph.assign(aliceRNode.getID(), aliceRecNode.getID()); graph.assign(aliceRWNode.getID(), aliceRecNode.getID()); // assign object attributes to policy classes graph.assign(salariesNode.getID(), pcNode.getID()); graph.assign(ssnsNode.getID(), pcNode.getID()); graph.assign(grp1SalariesNode.getID(), pcNode.getID()); graph.assign(grp2SalariesNode.getID(), pcNode.getID()); graph.assign(publicNode.getID(), pcNode.getID()); graph.assign(bobRecNode.getID(), pcNode.getID()); graph.assign(aliceRecNode.getID(), pcNode.getID()); // associations Set<String> rw = new HashSet<>(Arrays.asList(\"r\", \"w\")); Set<String> r = new HashSet<>(Arrays.asList(\"r\")); graph.associate(hrNode.getID(), salariesNode.getID(), rw); graph.associate(hrNode.getID(), ssnsNode.getID(), rw); graph.associate(grp1MgrNode.getID(), grp1SalariesNode.getID(), r); graph.associate(grp2MgrNode.getID(), grp2SalariesNode.getID(), r); graph.associate(staffNode.getID(), publicNode.getID(), r); graph.associate(bobUANode.getID(), bobRWNode.getID(), rw); graph.associate(bobUANode.getID(), bobRNode.getID(), r); graph.associate(aliceUANode.getID(), aliceRWNode.getID(), rw); graph.associate(aliceUANode.getID(), aliceRNode.getID(), r); // test configuration // create a decider // not using prohibitions in this example, so null is passed Decider decider = new PReviewDecider(graph); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] Set<String> permissions = decider.listPermissions(bobNode.getID(), bobSSNNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: bob // target: 'bob ssn' // expected: [r] // actual: [r] permissions = decider.listPermissions(bobNode.getID(), bobSalaryNode.getID()); assertTrue(permissions.contains(\"r\")); // user: bob // target: 'alice ssn' // expected: [] // actual: [] permissions = decider.listPermissions(bobNode.getID(), aliceSSNNode.getID()); assertTrue(permissions.isEmpty()); // user: bob // target: 'alice salary' // expected: [] // actual: [] permissions = decider.listPermissions(bobNode.getID(), aliceSalaryNode.getID()); assertTrue(permissions.isEmpty()); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(aliceNode.getID(), aliceSSNNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: charlie // target: 'alice salary' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(charlieNode.getID(), aliceSalaryNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); Visualization Below is a visual representation of the graph created in the employee record example. Audit Explain Using the bank teller example described above , auditor.explain(user1Node.getID(), objectNode.getID()) will result in: operations: [r, w] policyClasses: RBAC operations: [r, w] paths: - u1-Teller-Accounts-o1 ops=[r, w] branches operations: [r, w] paths: - u1-branch 1-branch 1-o1 ops=[r, w] Obligations Obligation YAML The below obligation yaml creates a rule that when any user assigns anything to oa1, create a new node called \"new OA\" and assign it to oa1 if the node o1 is assigned to oa1. label: test rules: - label: rule1 event: subject: operations: - assign to target: policyElements: - name: oa1 type: OA response: condition: - function: name: is_node_contained_in args: - function: name: get_node args: - o1 - O - function: name: get_node args: - oa1 - OA actions: - create: what: - name: new OA type: OA properties: k: v where: - name: oa1 type: OA Loading Obligation InputStream is = getClass().getClassLoader().getResourceAsStream(\"obligation.yml\"); Obligation obligation = EVRParser.parse(is); Obligations obligations = new MemObligations(); // add the obligation and enable it pdp.getPAP().getObligationsPAP().add(obligation, true); Processing Event pdp.getEPP().processEvent(new AssignToEvent(oa1, o1), userID, processID);","title":"Examples"},{"location":"examples/#serialization","text":"","title":"Serialization"},{"location":"examples/#graph","text":"There are two ways to serialize a graph. This first is to serialize it into json. The second is a command like structure that is easier to read than json.","title":"Graph"},{"location":"examples/#json","text":"Graph graph = new MemGraph(); --- String json = GraphSerializer.toJson(graph); Deserialize a json string to a graph. Graph graph = GraphSerializer.fromJson(new MemGraph(), json);","title":"JSON"},{"location":"examples/#readable-format","text":"There are three primary commands for the readable format: node , assign , and assoc . node PC pc1 node OA oa1 node UA ua1 node O o1 node U u1 assign OA:oa1 PC:pc1 assign UA:ua1 PC:pc1 assign O:o1 OA:oa1 assign U:u1 UA:ua1 assoc UA:ua1 OA:oa1 [read,write] String serialize = GraphSerializer.serialize(graph); Graph deSerialize = GraphSerializer.deserialize(graph);","title":"Readable Format"},{"location":"examples/#prohibitions","text":"Serialize a ProhibitionDAO into a json string. ProhibitionsDAO dao = new MemProhibitionsDAO(); --- String json = ProhibitionsSerializer.toJson(dao); Deserialize a json string to a ProhibitionsDAO. ProhibitionsDAO deDao = ProhibitionsSerializer.fromJson(new MemProhibitionsDAO(), json);","title":"Prohibitions"},{"location":"examples/#bank-teller","text":"","title":"Bank Teller"},{"location":"examples/#graph-configuration-summary","text":"Users: u1, u2 An object o1 Two policy classes: RBAC and Branches RBAC o1 is assigned to accounts u1 is a Teller that has read and write permissions on accounts u2 is an Auditor that has read permissions on accounts Branches u1 and u2 are both assigned to the Branch 1 user attribute o1 is assigned to the Branch 1 object attribute the Branch 1 user attribute has read and write permissions on the Branch 1 object attribute","title":"Graph configuration summary"},{"location":"examples/#access-control-state","text":"u1 can read and write o1 u2 can read o1","title":"Access control state"},{"location":"examples/#code-wakthrough","text":"// 1. Create a new Graph instance. For this example, we'll use the `MemGraph` which is an in memory implementation of the Graph interface. Graph graph = new MemGraph(); // 2. Create the user nodes `u1` and `u2`. Node user1Node = graph.createNode(rand.nextLong(), \"u1\", U, null); Node user2Node = graph.createNode(rand.nextLong(), \"u2\", U, null); // 3. Create the object, `o1` that will be the target of the access queries. Node objectNode = graph.createNode(rand.nextLong(), \"o1\", O, null); // 4. Create the `RBAC` policy class node. Node rbacNode = graph.createNode(rand.nextLong(), \"RBAC\", PC, null); // 5. Create an object attribute for the `Accounts`. Node accountsNode = graph.createNode(rand.nextLong(), \"Accounts\", OA, null); // 6. Create the `Teller` and `Auditor` user attributes. Node tellerNode = graph.createNode(rand.nextLong(), \"Teller\", UA, null); Node auditorNode = graph.createNode(rand.nextLong(), \"Auditor\", UA, null); // 7. Assign the `Accounts` object attribute to the `RBAC` policy class node. graph.assign(accountsNode.getID(), rbacNode.getID()); // 8. Assign the object, `o1`, to the `Accounts` object attribute. graph.assign(objectNode.getID(), accountsNode.getID()); // 9. Assign `u1` to the `Teller` user attribute and `u2` to the `Auditor` user attribute. graph.assign(user1Node.getID(), tellerNode.getID()); graph.assign(user2Node.getID(), auditorNode.getID()); // 10. Create the associations for `Teller` and `Auditor` on `Account` in RBAC. `Teller` has read and write permissions, while `Auditor` just has read permissions. graph.associate(tellerNode.getID(), accountsNode.getID(), new HashSet<>(Arrays.asList(\"r\", \"w\"))); graph.associate(auditorNode.getID(), accountsNode.getID(), new HashSet<>(Arrays.asList(\"r\"))); // 11. Create the `Branches` policy class. Node branchesNode = graph.createNode(rand.nextLong(), \"branches\", PC, null); // 12. Create an object attribute for `Branch 1`. Node branch1OANode = graph.createNode(rand.nextLong(), \"branch 1\", OA, null); // 13. Assign the branch 1 OA to the branches PC graph.assign(branch1OANode.getID(), branchesNode.getID()); // 14. Create the `Branch 1` user attribute Node branches1UANode = graph.createNode(rand.nextLong(), \"branch 1\", UA, null); // 15. Assign the object, `o1`, to the `Branch 1` object attribute graph.assign(objectNode.getID(), branch1OANode.getID()); // 16. Assign the users, `u1` and `u2`, to the branch 1 user attribute graph.assign(user1Node.getID(), branches1UANode.getID()); graph.assign(user2Node.getID(), branches1UANode.getID()); // 17. Create an association between the `branch 1` user attribute and the `branch 1` object attribute. //This will give both users read and write on `o1` under the `branches` policy class. graph.associate(branches1UANode.getID(), branch1OANode.getID(), new HashSet<>(Arrays.asList(\"r\", \"w\"))); To make access decisions: // 18. Test the configuration using the `PReviewDecider` implementation of the `Decider` interface. //The constructor for a `PReviewDecider` receives the graph we created and a list of prohibitions. //Since no prohibitions are used in this example, we'll pass null. Decider decider = new PReviewDecider(graph); // 19. Check that `u1` has read and write permissions on `o1`. Set<String> permissions = decider.listPermissions(user1Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // 20. Check that `u1` has read permissions on `o1`. permissions = decider.listPermissions(user2Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\"));","title":"Code Wakthrough"},{"location":"examples/#visualization","text":"Below is a visual representation of the graph created in the bank teller example.","title":"Visualization"},{"location":"examples/#employee-record","text":"","title":"Employee Record"},{"location":"examples/#example-configuration-summary","text":"One policy class Users: bob, alice, charlie The objects are bob's and alice's name, salary, and ssn. All users are assigned to the Staff user attribute The Staff user attribute has read permissions on Public Info, which in this case is names. Charlie has the HR attribute HR has read and write permissions on Salaries and SSNs Bob and Alice have the Grp1Mgr and Grp2Mgr attributes, respectively Grp1Mgr and Grp2Mgr have read permissions on Grp1Salaries and Grp2Salaries, respectively Bob and Alice have read and write permissions on their name and ssn, and read permissions on their salaries.","title":"Example configuration summary"},{"location":"examples/#access-control-state_1","text":"Alice can read and write her name and SSN, and read her salary, and the salaries of those in Group 2. Bob can read and write his name and SSN, and read his salary, and salaries of those in Group 1. Charlie can read and write all salaries and SSNs, and read all names. Graph graph = new MemGraph(); // create nodes // object attributes Node salariesNode = graph.createNode(rand.nextLong(), \"Salaries\", OA, null); Node ssnsNode = graph.createNode(rand.nextLong(), \"SSNs\", OA, null); Node grp1SalariesNode = graph.createNode(rand.nextLong(), \"Grp1 Salaries\", OA, null); Node grp2SalariesNode = graph.createNode(rand.nextLong(), \"Grp2 Salaries\", OA, null); Node publicNode = graph.createNode(rand.nextLong(), \"Public Info\", OA, null); Node bobRecNode = graph.createNode(rand.nextLong(), \"Bob Record\", OA, null); Node bobRNode = graph.createNode(rand.nextLong(), \"Bob r\", OA, null); Node bobRWNode = graph.createNode(rand.nextLong(), \"Bob r/w\", OA, null); Node aliceRecNode = graph.createNode(rand.nextLong(), \"Alice Record\", OA, null); Node aliceRNode = graph.createNode(rand.nextLong(), \"Alice r\", OA, null); Node aliceRWNode = graph.createNode(rand.nextLong(), \"Alice r/w\", OA, null); // objects for bob's name, salary, and ssn Node bobNameNode = graph.createNode(rand.nextLong(), \"bob name\", O, null); Node bobSalaryNode = graph.createNode(rand.nextLong(), \"bob salary\", O, null); Node bobSSNNode = graph.createNode(rand.nextLong(), \"bob ssn\", O, null); // objects for alice's name, salary, and ssn Node aliceNameNode = graph.createNode(rand.nextLong(), \"alice name\", O, null); Node aliceSalaryNode = graph.createNode(rand.nextLong(), \"alice salary\", O, null); Node aliceSSNNode = graph.createNode(rand.nextLong(), \"alice ssn\", O, null); // user attributes Node hrNode = graph.createNode(rand.nextLong(), \"HR\", UA, null); Node grp1MgrNode = graph.createNode(rand.nextLong(), \"Grp1Mgr\", UA, null); Node grp2MgrNode = graph.createNode(rand.nextLong(), \"Grp2Mgr\", UA, null); Node staffNode = graph.createNode(rand.nextLong(), \"Staff\", UA, null); Node bobUANode = graph.createNode(rand.nextLong(), \"Bob\", UA, null); Node aliceUANode = graph.createNode(rand.nextLong(), \"Alice\", UA, null); // users Node bobNode = graph.createNode(rand.nextLong(), \"bob\", U, null); Node aliceNode = graph.createNode(rand.nextLong(), \"alice\", U, null); Node charlieNode = graph.createNode(rand.nextLong(), \"charlie\", U, null); // policy class Node pcNode = graph.createNode(rand.nextLong(), \"Employee Records\", PC, null); // assignments // assign users to user attributes graph.assign(charlieNode.getID(), hrNode.getID()); graph.assign(bobNode.getID(), grp1MgrNode.getID()); graph.assign(aliceNode.getID(), grp2MgrNode.getID()); graph.assign(charlieNode.getID(), staffNode.getID()); graph.assign(bobNode.getID(), staffNode.getID()); graph.assign(aliceNode.getID(), staffNode.getID()); graph.assign(bobNode.getID(), bobUANode.getID()); graph.assign(aliceNode.getID(), aliceUANode.getID()); // assign objects to object attributes // salary objects graph.assign(bobSalaryNode.getID(), salariesNode.getID()); graph.assign(bobSalaryNode.getID(), grp1SalariesNode.getID()); graph.assign(bobSalaryNode.getID(), bobRNode.getID()); graph.assign(aliceSalaryNode.getID(), salariesNode.getID()); graph.assign(aliceSalaryNode.getID(), grp2SalariesNode.getID()); graph.assign(aliceSalaryNode.getID(), aliceRNode.getID()); // ssn objects graph.assign(bobSSNNode.getID(), ssnsNode.getID()); graph.assign(bobSSNNode.getID(), bobRWNode.getID()); graph.assign(aliceSSNNode.getID(), aliceNode.getID()); graph.assign(aliceSSNNode.getID(), aliceRWNode.getID()); // name objects graph.assign(bobNameNode.getID(), publicNode.getID()); graph.assign(bobNameNode.getID(), bobRWNode.getID()); graph.assign(aliceNameNode.getID(), publicNode.getID()); graph.assign(aliceNameNode.getID(), aliceRWNode.getID()); // bob and alice r/w containers to their records graph.assign(bobRNode.getID(), bobRecNode.getID()); graph.assign(bobRWNode.getID(), bobRecNode.getID()); graph.assign(aliceRNode.getID(), aliceRecNode.getID()); graph.assign(aliceRWNode.getID(), aliceRecNode.getID()); // assign object attributes to policy classes graph.assign(salariesNode.getID(), pcNode.getID()); graph.assign(ssnsNode.getID(), pcNode.getID()); graph.assign(grp1SalariesNode.getID(), pcNode.getID()); graph.assign(grp2SalariesNode.getID(), pcNode.getID()); graph.assign(publicNode.getID(), pcNode.getID()); graph.assign(bobRecNode.getID(), pcNode.getID()); graph.assign(aliceRecNode.getID(), pcNode.getID()); // associations Set<String> rw = new HashSet<>(Arrays.asList(\"r\", \"w\")); Set<String> r = new HashSet<>(Arrays.asList(\"r\")); graph.associate(hrNode.getID(), salariesNode.getID(), rw); graph.associate(hrNode.getID(), ssnsNode.getID(), rw); graph.associate(grp1MgrNode.getID(), grp1SalariesNode.getID(), r); graph.associate(grp2MgrNode.getID(), grp2SalariesNode.getID(), r); graph.associate(staffNode.getID(), publicNode.getID(), r); graph.associate(bobUANode.getID(), bobRWNode.getID(), rw); graph.associate(bobUANode.getID(), bobRNode.getID(), r); graph.associate(aliceUANode.getID(), aliceRWNode.getID(), rw); graph.associate(aliceUANode.getID(), aliceRNode.getID(), r); // test configuration // create a decider // not using prohibitions in this example, so null is passed Decider decider = new PReviewDecider(graph); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] Set<String> permissions = decider.listPermissions(bobNode.getID(), bobSSNNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: bob // target: 'bob ssn' // expected: [r] // actual: [r] permissions = decider.listPermissions(bobNode.getID(), bobSalaryNode.getID()); assertTrue(permissions.contains(\"r\")); // user: bob // target: 'alice ssn' // expected: [] // actual: [] permissions = decider.listPermissions(bobNode.getID(), aliceSSNNode.getID()); assertTrue(permissions.isEmpty()); // user: bob // target: 'alice salary' // expected: [] // actual: [] permissions = decider.listPermissions(bobNode.getID(), aliceSalaryNode.getID()); assertTrue(permissions.isEmpty()); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(aliceNode.getID(), aliceSSNNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: charlie // target: 'alice salary' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(charlieNode.getID(), aliceSalaryNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\"));","title":"Access control state"},{"location":"examples/#visualization_1","text":"Below is a visual representation of the graph created in the employee record example.","title":"Visualization"},{"location":"examples/#audit","text":"","title":"Audit"},{"location":"examples/#explain","text":"Using the bank teller example described above , auditor.explain(user1Node.getID(), objectNode.getID()) will result in: operations: [r, w] policyClasses: RBAC operations: [r, w] paths: - u1-Teller-Accounts-o1 ops=[r, w] branches operations: [r, w] paths: - u1-branch 1-branch 1-o1 ops=[r, w]","title":"Explain"},{"location":"examples/#obligations","text":"","title":"Obligations"},{"location":"examples/#obligation-yaml","text":"The below obligation yaml creates a rule that when any user assigns anything to oa1, create a new node called \"new OA\" and assign it to oa1 if the node o1 is assigned to oa1. label: test rules: - label: rule1 event: subject: operations: - assign to target: policyElements: - name: oa1 type: OA response: condition: - function: name: is_node_contained_in args: - function: name: get_node args: - o1 - O - function: name: get_node args: - oa1 - OA actions: - create: what: - name: new OA type: OA properties: k: v where: - name: oa1 type: OA","title":"Obligation YAML"},{"location":"examples/#loading-obligation","text":"InputStream is = getClass().getClassLoader().getResourceAsStream(\"obligation.yml\"); Obligation obligation = EVRParser.parse(is); Obligations obligations = new MemObligations(); // add the obligation and enable it pdp.getPAP().getObligationsPAP().add(obligation, true);","title":"Loading Obligation"},{"location":"examples/#processing-event","text":"pdp.getEPP().processEvent(new AssignToEvent(oa1, o1), userID, processID);","title":"Processing Event"},{"location":"functional-components/","text":"PIP The Policy Enforcement Point (PIP) package provides a set of interfaces for storing NGAC policy data and in memory implementations of each interface. The three interfaces Graph , Prohibitions , Obligations are explained below. Graph The Graph interface provides the set of functions necessary for maintaining and traversing an NGAC graph. MemGraph MemGraph is an in memory implementation of the Graph interface. The underlying structure is a directed acyclic graph which stores the node IDs as nodes in the graph. Edges represent assignments and associations. Graph graph = new MemGraph(); This will create a new instance of the in memory implementation of the Graph interface. Now it can be populated with nodes, assignments, and associations. A characteristic of NGAC graphs is that all nodes must be connected. You can start building a graph with Policy Classes by calling Node pc1 = graph.createPolicyClass(id, \"PC1\", null) Once a policy class is created, Object and User Attributes can then be created and assigned to the policy class Node ua = graph.createNode(id, \"UA1\", NodeType.UA, null, pc1.getID()); Node oa = graph.createNode(id, \"OA1\", NodeType.OA, null, pc1.getID()); It is possible to create a node and assign it to more than one parent Node oa1 = graph.createNode(id, \"OA1\", NodeType.OA, null, pc1.getID()); Node oa2 = graph.createNode(id, \"OA2\", NodeType.OA, null, pc1.getID()); Node o = graph.createNode(id, \"O1\", NodeType.O, null, oa1.getID(), oa2.getID()); The createNode method only requires one initial parent node, but assignments can still be made later on graph.assign(o1.getID(), oa3.getID()); To associate two nodes graph.associate(ua1.getID(), oa1.getID(), new OperationSet(\"read\", \"write\"))); This will associate the ua1 and oa1 nodes with read and write operations. Prohibitions The Prohibitions interface provides functions to maintain a list of prohibition relations. MemProhibitions MemProhibitions is an in memory implementation of the Prohibitions interface. Prohibitions are stored with respect to the subject of the prohibition. This allows for efficient look up later on. The following is an example of creating a Prohibition and adding it to a MemProhibitions instance: Prohibitions prohibitions = new MemProhibitions(); Prohibition prohibition = new Prohibition(); prohibition.setName(\"denyName\"); prohibition.setIntersection(true); prohibition.setOperations(new HashSet<>(Arrays.asList(\"read\", \"write\"))); prohibition.setSubject(new Prohibition.Subject(1234, Prohibition.Subject.Type.USER)); prohibition.addNode(new Prohibition.Node(4321, false)); prohibitions.add(prohibition); Obligations The Obligations interface provides functions to maintain a list of obligation relations. The obligation implementation is a little more complex than the prohibitions and will be explained in the obligations section. PAP The Policy Administration Point (PAP) provides a means for administering policies to the underlying data in the PIP. This package is very simple as it only sets up a middle man between the PDP/EPP and the PIP. PAP Functional Entity The PAP object is made up of a Graph , Prohibitions , and Obligations . It provides and single administration point for an NGAC system. PDP The Policy Decision Point (PDP) provides three main functionalities: Interfaces for querying the access state of an NGAC graph. An interface for auditing an NGAC graph. A PDP as a functional entity. Decider The decider package contains the Decider interface which provides methods to query the access state of an NGAC graph, and an implementation of this interface called PReviewDecider (short for Policy Review Decider). Usage The PReviewDecider receives a graph and prohibitions Decider decider = new PReviewDecider(graph, prohibitions); Access decisions can then be made using one of the several available methods Set<String> permissions = decder.list(userID, processID, targetID) Auditor The auditor package contains an interface that can be used to audit an NGAC graph. The interface has one method called explain which can explain why a user has permissions on a target node. An implementation called PReviewAuditor is provided. PDP Functional Entity The PDP functional entity leverages the interfaces described above to control access to an underlying PAP. PDP pdp = new PDP( new PAP( new MemGraph(), new MemProhibitions(), new MemObligations(), ) ); EPP Coming soon...","title":"Functional Components"},{"location":"functional-components/#pip","text":"The Policy Enforcement Point (PIP) package provides a set of interfaces for storing NGAC policy data and in memory implementations of each interface. The three interfaces Graph , Prohibitions , Obligations are explained below.","title":"PIP"},{"location":"functional-components/#graph","text":"The Graph interface provides the set of functions necessary for maintaining and traversing an NGAC graph.","title":"Graph"},{"location":"functional-components/#memgraph","text":"MemGraph is an in memory implementation of the Graph interface. The underlying structure is a directed acyclic graph which stores the node IDs as nodes in the graph. Edges represent assignments and associations. Graph graph = new MemGraph(); This will create a new instance of the in memory implementation of the Graph interface. Now it can be populated with nodes, assignments, and associations. A characteristic of NGAC graphs is that all nodes must be connected. You can start building a graph with Policy Classes by calling Node pc1 = graph.createPolicyClass(id, \"PC1\", null) Once a policy class is created, Object and User Attributes can then be created and assigned to the policy class Node ua = graph.createNode(id, \"UA1\", NodeType.UA, null, pc1.getID()); Node oa = graph.createNode(id, \"OA1\", NodeType.OA, null, pc1.getID()); It is possible to create a node and assign it to more than one parent Node oa1 = graph.createNode(id, \"OA1\", NodeType.OA, null, pc1.getID()); Node oa2 = graph.createNode(id, \"OA2\", NodeType.OA, null, pc1.getID()); Node o = graph.createNode(id, \"O1\", NodeType.O, null, oa1.getID(), oa2.getID()); The createNode method only requires one initial parent node, but assignments can still be made later on graph.assign(o1.getID(), oa3.getID()); To associate two nodes graph.associate(ua1.getID(), oa1.getID(), new OperationSet(\"read\", \"write\"))); This will associate the ua1 and oa1 nodes with read and write operations.","title":"MemGraph"},{"location":"functional-components/#prohibitions","text":"The Prohibitions interface provides functions to maintain a list of prohibition relations.","title":"Prohibitions"},{"location":"functional-components/#memprohibitions","text":"MemProhibitions is an in memory implementation of the Prohibitions interface. Prohibitions are stored with respect to the subject of the prohibition. This allows for efficient look up later on. The following is an example of creating a Prohibition and adding it to a MemProhibitions instance: Prohibitions prohibitions = new MemProhibitions(); Prohibition prohibition = new Prohibition(); prohibition.setName(\"denyName\"); prohibition.setIntersection(true); prohibition.setOperations(new HashSet<>(Arrays.asList(\"read\", \"write\"))); prohibition.setSubject(new Prohibition.Subject(1234, Prohibition.Subject.Type.USER)); prohibition.addNode(new Prohibition.Node(4321, false)); prohibitions.add(prohibition);","title":"MemProhibitions"},{"location":"functional-components/#obligations","text":"The Obligations interface provides functions to maintain a list of obligation relations. The obligation implementation is a little more complex than the prohibitions and will be explained in the obligations section.","title":"Obligations"},{"location":"functional-components/#pap","text":"The Policy Administration Point (PAP) provides a means for administering policies to the underlying data in the PIP. This package is very simple as it only sets up a middle man between the PDP/EPP and the PIP.","title":"PAP"},{"location":"functional-components/#pap-functional-entity","text":"The PAP object is made up of a Graph , Prohibitions , and Obligations . It provides and single administration point for an NGAC system.","title":"PAP Functional Entity"},{"location":"functional-components/#pdp","text":"The Policy Decision Point (PDP) provides three main functionalities: Interfaces for querying the access state of an NGAC graph. An interface for auditing an NGAC graph. A PDP as a functional entity.","title":"PDP"},{"location":"functional-components/#decider","text":"The decider package contains the Decider interface which provides methods to query the access state of an NGAC graph, and an implementation of this interface called PReviewDecider (short for Policy Review Decider).","title":"Decider"},{"location":"functional-components/#usage","text":"The PReviewDecider receives a graph and prohibitions Decider decider = new PReviewDecider(graph, prohibitions); Access decisions can then be made using one of the several available methods Set<String> permissions = decder.list(userID, processID, targetID)","title":"Usage"},{"location":"functional-components/#auditor","text":"The auditor package contains an interface that can be used to audit an NGAC graph. The interface has one method called explain which can explain why a user has permissions on a target node. An implementation called PReviewAuditor is provided.","title":"Auditor"},{"location":"functional-components/#pdp-functional-entity","text":"The PDP functional entity leverages the interfaces described above to control access to an underlying PAP. PDP pdp = new PDP( new PAP( new MemGraph(), new MemProhibitions(), new MemObligations(), ) );","title":"PDP Functional Entity"},{"location":"functional-components/#epp","text":"Coming soon...","title":"EPP"},{"location":"getting-started/","text":"Bank Teller To introduce you to the Policy Machine Core library we'll walk through a simple bank teller example. We'll create a graph, query the access state of the graph and audit the graph. Access Control State u1 can read and write o1 u2 can read o1 Graph Configuration Summary Users: u1 , u2 An object, o1 Two policy classes: RBAC and Branches RBAC o1 is assigned to accounts u1 is a Teller that has read and write permissions on accounts u2 is an Auditor that has read permissions on accounts Branches u1 and u2 are both assigned to the Branch 1 user attribute o1 is assigned to the Branch 1 object attribute the Branch 1 user attribute has read and write permissions on the Branch 1 object attribute Building the Graph // 1. Create a new Graph instance. For this example, we'll use the `MemGraph` which is an in memory implementation of the Graph interface. Graph graph = new MemGraph(); // 2. Create the user nodes `u1` and `u2`. Node user1Node = graph.createNode(rand.nextLong(), \"u1\", U, null); Node user2Node = graph.createNode(rand.nextLong(), \"u2\", U, null); // 3. Create the object, `o1` that will be the target of the access queries. Node objectNode = graph.createNode(rand.nextLong(), \"o1\", O, null); // 4. Create the `RBAC` policy class node. Node rbacNode = graph.createNode(rand.nextLong(), \"RBAC\", PC, null); // 5. Create an object attribute for the `Accounts`. Node accountsNode = graph.createNode(rand.nextLong(), \"Accounts\", OA, null); // 6. Create the `Teller` and `Auditor` user attributes. Node tellerNode = graph.createNode(rand.nextLong(), \"Teller\", UA, null); Node auditorNode = graph.createNode(rand.nextLong(), \"Auditor\", UA, null); // 7. Assign the `Accounts` object attribute to the `RBAC` policy class node. graph.assign(accountsNode.getID(), rbacNode.getID()); // 8. Assign the object, `o1`, to the `Accounts` object attribute. graph.assign(objectNode.getID(), accountsNode.getID()); // 9. Assign `u1` to the `Teller` user attribute and `u2` to the `Auditor` user attribute. graph.assign(user1Node.getID(), tellerNode.getID()); graph.assign(user2Node.getID(), auditorNode.getID()); // 10. Create the associations for `Teller` and `Auditor` on `Account` in RBAC. `Teller` has read and write permissions, while `Auditor` just has read permissions. Set rw = new HashSet<>(Arrays.asList(\"r\", \"w\")); Set r = new HashSet<>(Arrays.asList(\"r\")); graph.associate(tellerNode.getID(), accountsNode.getID(), rw); graph.associate(auditorNode.getID(), accountsNode.getID(), r); // 11. Create the `Branches` policy class. Node branchesNode = graph.createNode(rand.nextLong(), \"branches\", PC, null); // 12. Create an object attribute for `Branch 1`. Node branch1OANode = graph.createNode(rand.nextLong(), \"branch 1\", OA, null); // 13. Assign the branch 1 OA to the branches PC graph.assign(branch1OANode.getID(), branchesNode.getID()); // 14. Create the `Branch 1` user attribute Node branches1UANode = graph.createNode(rand.nextLong(), \"branch 1\", UA, null); // 15. Assign the object, `o1`, to the `Branch 1` object attribute graph.assign(objectNode.getID(), branch1OANode.getID()); // 16. Assign the users, `u1` and `u2`, to the branch 1 user attribute graph.assign(user1Node.getID(), branches1UANode.getID()); graph.assign(user2Node.getID(), branches1UANode.getID()); // 17. Create an association between the `branch 1` user attribute and the `branch 1` object attribute. //This will give both users read and write on `o1` under the `branches` policy class. graph.associate(branches1UANode.getID(), branch1OANode.getID(), rw); Making Access Decisions // 18. Test the configuration using the `PReviewDecider` implementation of the `Decider` interface. // The constructor for a `PReviewDecider` receives the graph we created and a list of prohibitions. // Since no prohibitions are used in this example, we'll pass null. Decider decider = new PReviewDecider(graph); // 19. Check that `u1` has read and write permissions on `o1`. Set<String> permissions = decider.listPermissions(user1Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // 20. Check that `u1` has read permissions on `o1`. permissions = decider.listPermissions(user2Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\")); Auditing the Graph Let's audit the graph to see why u1 has permissions on o1 . Auditor auditor = new PReviewAuditor(graph); Explain explain = auditor.explain(user1Node.getID(), objectNode.getID()) The result of the explain method will be structured as: operations: [r, w] policyClasses: RBAC operations: [r, w] paths: - u1-Teller-Accounts-o1 ops=[r, w] branches operations: [r, w] paths: - u1-branch 1-branch 1-o1 ops=[r, w] Visualization Below is a visual representation of the graph created in the bank teller example.","title":"Getting started"},{"location":"getting-started/#bank-teller","text":"To introduce you to the Policy Machine Core library we'll walk through a simple bank teller example. We'll create a graph, query the access state of the graph and audit the graph.","title":"Bank Teller"},{"location":"getting-started/#access-control-state","text":"u1 can read and write o1 u2 can read o1","title":"Access Control State"},{"location":"getting-started/#graph-configuration-summary","text":"Users: u1 , u2 An object, o1 Two policy classes: RBAC and Branches RBAC o1 is assigned to accounts u1 is a Teller that has read and write permissions on accounts u2 is an Auditor that has read permissions on accounts Branches u1 and u2 are both assigned to the Branch 1 user attribute o1 is assigned to the Branch 1 object attribute the Branch 1 user attribute has read and write permissions on the Branch 1 object attribute","title":"Graph Configuration Summary"},{"location":"getting-started/#building-the-graph","text":"// 1. Create a new Graph instance. For this example, we'll use the `MemGraph` which is an in memory implementation of the Graph interface. Graph graph = new MemGraph(); // 2. Create the user nodes `u1` and `u2`. Node user1Node = graph.createNode(rand.nextLong(), \"u1\", U, null); Node user2Node = graph.createNode(rand.nextLong(), \"u2\", U, null); // 3. Create the object, `o1` that will be the target of the access queries. Node objectNode = graph.createNode(rand.nextLong(), \"o1\", O, null); // 4. Create the `RBAC` policy class node. Node rbacNode = graph.createNode(rand.nextLong(), \"RBAC\", PC, null); // 5. Create an object attribute for the `Accounts`. Node accountsNode = graph.createNode(rand.nextLong(), \"Accounts\", OA, null); // 6. Create the `Teller` and `Auditor` user attributes. Node tellerNode = graph.createNode(rand.nextLong(), \"Teller\", UA, null); Node auditorNode = graph.createNode(rand.nextLong(), \"Auditor\", UA, null); // 7. Assign the `Accounts` object attribute to the `RBAC` policy class node. graph.assign(accountsNode.getID(), rbacNode.getID()); // 8. Assign the object, `o1`, to the `Accounts` object attribute. graph.assign(objectNode.getID(), accountsNode.getID()); // 9. Assign `u1` to the `Teller` user attribute and `u2` to the `Auditor` user attribute. graph.assign(user1Node.getID(), tellerNode.getID()); graph.assign(user2Node.getID(), auditorNode.getID()); // 10. Create the associations for `Teller` and `Auditor` on `Account` in RBAC. `Teller` has read and write permissions, while `Auditor` just has read permissions. Set rw = new HashSet<>(Arrays.asList(\"r\", \"w\")); Set r = new HashSet<>(Arrays.asList(\"r\")); graph.associate(tellerNode.getID(), accountsNode.getID(), rw); graph.associate(auditorNode.getID(), accountsNode.getID(), r); // 11. Create the `Branches` policy class. Node branchesNode = graph.createNode(rand.nextLong(), \"branches\", PC, null); // 12. Create an object attribute for `Branch 1`. Node branch1OANode = graph.createNode(rand.nextLong(), \"branch 1\", OA, null); // 13. Assign the branch 1 OA to the branches PC graph.assign(branch1OANode.getID(), branchesNode.getID()); // 14. Create the `Branch 1` user attribute Node branches1UANode = graph.createNode(rand.nextLong(), \"branch 1\", UA, null); // 15. Assign the object, `o1`, to the `Branch 1` object attribute graph.assign(objectNode.getID(), branch1OANode.getID()); // 16. Assign the users, `u1` and `u2`, to the branch 1 user attribute graph.assign(user1Node.getID(), branches1UANode.getID()); graph.assign(user2Node.getID(), branches1UANode.getID()); // 17. Create an association between the `branch 1` user attribute and the `branch 1` object attribute. //This will give both users read and write on `o1` under the `branches` policy class. graph.associate(branches1UANode.getID(), branch1OANode.getID(), rw);","title":"Building the Graph"},{"location":"getting-started/#making-access-decisions","text":"// 18. Test the configuration using the `PReviewDecider` implementation of the `Decider` interface. // The constructor for a `PReviewDecider` receives the graph we created and a list of prohibitions. // Since no prohibitions are used in this example, we'll pass null. Decider decider = new PReviewDecider(graph); // 19. Check that `u1` has read and write permissions on `o1`. Set<String> permissions = decider.listPermissions(user1Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // 20. Check that `u1` has read permissions on `o1`. permissions = decider.listPermissions(user2Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\"));","title":"Making Access Decisions"},{"location":"getting-started/#auditing-the-graph","text":"Let's audit the graph to see why u1 has permissions on o1 . Auditor auditor = new PReviewAuditor(graph); Explain explain = auditor.explain(user1Node.getID(), objectNode.getID()) The result of the explain method will be structured as: operations: [r, w] policyClasses: RBAC operations: [r, w] paths: - u1-Teller-Accounts-o1 ops=[r, w] branches operations: [r, w] paths: - u1-branch 1-branch 1-o1 ops=[r, w]","title":"Auditing the Graph"},{"location":"getting-started/#visualization","text":"Below is a visual representation of the graph created in the bank teller example.","title":"Visualization"},{"location":"installation/","text":"Install using Maven Policy Machine Core uses JitPack to compile and build the artifact to import into projects. First, add jitpack as a repository <project> -- <repositories> <repository> <id>jitpack.io</id> <url>https://jitpack.io</url> </repository> </repositories> -- </project> Then, add the maven dependency <dependency> <groupId>com.github.PM-Master</groupId> <artifactId>policy-machine-core</artifactId> <version>LATEST</version> </dependency> That's it, now the policy-machine-core library will be available for use! Releases View the policy-machine-core releases on github","title":"Installation"},{"location":"installation/#install-using-maven","text":"Policy Machine Core uses JitPack to compile and build the artifact to import into projects. First, add jitpack as a repository <project> -- <repositories> <repository> <id>jitpack.io</id> <url>https://jitpack.io</url> </repository> </repositories> -- </project> Then, add the maven dependency <dependency> <groupId>com.github.PM-Master</groupId> <artifactId>policy-machine-core</artifactId> <version>LATEST</version> </dependency> That's it, now the policy-machine-core library will be available for use!","title":"Install using Maven"},{"location":"installation/#releases","text":"View the policy-machine-core releases on github","title":"Releases"},{"location":"obligations/","text":"Obligations Obligations are defined using a yaml syntax described below. Examples can be found here . Common Elements Nodes A node represents a node in an NGAC graph. A node has a name, type, and properties. A node can also be derived from a function. name: type: properties: - key: value function A function refers to a previously defined function that is supported by the Policy Machine Event Processing Point (EPP). A list of valid functions, as well as tutorial on how to add functions can be found here . Example function: name: args: - \"\" - function: A function has a name and a list of arguments. The arguments are a list of string values or other functions. Obligation There is one obligation per yaml file. An obligation can have zero or more rules. label: rules: label - A label to give the obligation. If one is not specified, then a random value will be used. rules - Contains a set of zero or more rules. Rule label: event: response: label - A label to give the rule. If one is not specified a random value will be used. event - The event pattern for this rule. response - The response to the event. Event Pattern event: subject: policyClass: operations: target: The Event Pattern specifies an event involving the policy elements of the Policy Machine. An example is a user performing a read operation on an object. This is called an access event, which is the primary focus of obligations as described in the NGAC standard. An access event has four components: The subject, policy class, operations, and target. All of these are optional, but omitting them will have different consequences, which will be described in the sections below. While the Policy Machine focuses on access events, it is possible to extend the functionality of the Event Pattern to other events such as time. The section How to Extend the Event Pattern section provides a tutorial on how this is possible with the Policy Machine. Subject subject: user: anyUser: process: The subject specification can be a user, any user, any user from a set of users and/or user attributes, or a process. If the subject is omitted than all events will match this component of an access event. user A user is identified by it's name. any_user anyUser: The any_user element accepts an array of strings representing user names. If the element is empty then any user will match. process process: The process element accepts a number as a process ID. Example: anyUser: # any user ### anyUser: # u1 or u2 - \"u1\" - \"u2\" process: 12345 Policy Class policyClass: anyOf: --- eachOf: The policy class specification can specify a particular policy class with a given name, any policy class, any policy class from a set, all policy classes from a set, or all policy classes. Only one of anyOf and eachOf are allowed. Example ### policyClass: # any policy class ### policyClass: # PC1 or PC2 anyOf: - \"PC1\" - \"PC2\" ### policyClass: # PC1 and PC2 eachOf: - \"PC1\" - \"PC2\" Operations operations: - \"op\" The operations specification is a string array of operation names. Any event that matches an element of the array will match the operations event pattern. Example: operations: - \"read\" - \"write\" Target The target of an event can be A specific policy element policyElements: - name: name type: type Any policy element policyElements: * Omitting policyElements will have the same effect Any policy element that is contained in other policy elements containers: - name: type: - name: type: Any policy element from a set of policy elements policyElements: - name: name type: type - name: name type: type If both policyElements and containers are omitted it will be \"any policyElement in any container\" If containers is present then it will be \"any policyElement in the containers\", regardless of if policyElements is present If policyElements is present its \"any policyElement from the list provided\" Response A response is a series of conditional actions. A condition can also be applied to the response itself. Condition A condition is a set of boolean expressions that if all evaluate to true, allow for a response or specific action to be executed. condition: - function: - function: Create Action You can create a set of rules a set of nodes rule create: - label: event: response: nodes Create a single node and assign it to an already existing node in the graph. An array of commands is accepted to create more than one node. Functions are not allowed here . create: - what: name: node1 type: UA where: name: container1 type: UA Assign Action assign: what: where: The what and where nodes. The node in what will be assigned to the node in where . Grant Action Associate the node in subject with the node in target . grant: subject: operations: target: subject a node that will be the subject of the association. operations is an array of operations to add to the association. target a node that will be the target of the association. Deny Action (Prohibition) Deny a subject a set of operations on a set of target attributes. The subject can be a function, a process, or a node. The operations are an array of string. The target of the deny can be the intersection of a set of containers. It can also be the complement of the logical evaluation of the containers. Each container is identified by a name and type (properties are optional). If more than one node matches the provided name and type all will be taken into account. It is possible to take the complement of an individual container using the complement element. A deny also has a label that can be used to reference it later (i.e. to delete). deny: label: # string subject: # priority goes 1. function, 2. process, 3. node function: --- process: --- name: type: properties: operations: - \"\" - \"\" target: complement: # true|false, default false intersection: # true|false, default false containers: - name: type: complement: # true|false, default false - function: complement: # true|false Delete Action The delete action can delete: nodes assignments associations prohibitions (denies) rules delete: nodes: - name: type: assignments: - what: name: type: where: name: type: associations: - subject: target: prohibitions: - label: rules: - label: Fuction as Action You can define a function as a direct action in the response. function: name: args: Functions There are two main types of functions: utility and administrative. Utility functions are functions which aid in writing and executing obligations. Administrative functions provide a convenient way of bundling several administrative commands together. Predefined Functions This is a list of functions that are built into the library. They are all utility functions. child_of_assign Description Return the node that is the child of the assignment that is the focus of the event. Parameters None Return Node Event Requirements The event must assign , assign to , deassign or deassign from . Example function: name: child_of_assign parent_of_assign Description Return the node that is the child of the assignment that is the focus of the event. Parameters None Return Node Event Requirements The event must assign , assign to , deassign or deassign from . Example function: name: child_of_assign create_node Description Create a new node and return it. Parameters parentName: parentType: name: string type: string properties: function ( to_props ) Return Node Event Requirements None Example function: name: create_node args: - \"parentNode\" - \"OA\" - \"newNode\" - \"OA\" - function: name: to_props args: - \"key1=value1\" - \"key2=value2\" current_process Description Return the current process ID Parameters None Return long Event Requirements None Example function: name: current_process current_target Description Return the node that is the target of the event being processed Parameters None Return Node Event Requirements None Example function: name: current_target current_user Description Return the user that triggered the event being processed Parameters None Return Node Event Requirements None Example function: name: current_user current_user_to_deny_subject Description Return a Prohibition.Subject with the current user. Parameters None Return Prohibition.Subject Event Requirements None Example function: name: current_user_to_deny_subject get_children Description Returns the children of a node. Parameters name: string type: string properties: function ( to_props ) Return List<Node> Event Requirements None Example function: name: get_children args: - \"oa1\" - \"OA\" - function: name: to_props args: - \"key=value\" get_node Description Returns the node that matches the given name, type, and properties. Parameters name: string type: string properties: function ( to_props ) Return Node Event Requirements None Example function: name: get_node args: - \"oa1\" - \"OA\" - function: name: to_props args: - \"key=value\" get_node_name Description Returns the name of the node that is returned by the function passed as the parameter. Parameters node: function Return String Event Requirements None Example function: name: get_node_name args: - function: name: current_target is_node_contained_in Description Returns true if the node passed as the first parameter is assigned to the node passed as the second parameter. Both parameters are expected to be functions. Parameters child: function parent: funtion Return boolean Event Requirements None Example function: name: is_node_contained_in args: - function: name: get_node args: - \"oa1\" - \"OA\" - function: name: get_node args: - \"oa1\" - \"OA\" to_props Description Converts an array of strings with the format = to a Map . Parameters strings: array Return Map<String, String> Event Requirements None Example function: name: to_props args: - \"key1=value1\" - \"key2=value2\" Custom Functions To create your own function follow the pattern used in the gov.nist.csd.pm.epp.functions package. 1. Implement FunctionExecutor Interface Create a class that implements the gov.nist.csd.pm.epp.functions.FunctionExecutor interface. /** * The name of the function * @return the name of the function. */ String getFunctionName(); /** * How many parameters are expected. * @return the number of parameters this function expects */ int numParams(); /** * Execute the function. * @param eventCtx The event that is being processed * @param userID The ID of the user that triggered the event * @param processID The ID of the process that triggered the event * @param pdp The PDP to access the underlying policy data * @param function The function information * @param functionEvaluator A FunctionEvaluator to evaluate a nested functions * @return The object that the function is expected to return * @throws PMException If there is any error executing the function */ Object exec(EventContext eventCtx, long userID, long processID, PDP pdp, Function function, FunctionEvaluator functionEvaluator) throws PMException; 2. Provide the EPP with the Function Executor To make your custom function available to the EPP, use this EPP constructor: public EPP(PDP pdp, FunctionExecutor ... executors) throws PMException { ... } Any executors that are provided to this constructor will be available to the EPP when processing events. PDP Events The following events are triggered by the PDP: Assign Assign to Deassign Deassign From For each call to assign() and deassign() in the PDP, there are two events. The child is being assigned/deassigned and the parent is being assigned to/deassigned from. These are only the built in events. Also, the PDP is not the only component that can trigger an event. The PEP is also capable of triggering events of any kind. This is where custom events can be triggered.","title":"Obligations"},{"location":"obligations/#obligations","text":"Obligations are defined using a yaml syntax described below. Examples can be found here .","title":"Obligations"},{"location":"obligations/#common-elements","text":"","title":"Common Elements"},{"location":"obligations/#nodes","text":"A node represents a node in an NGAC graph. A node has a name, type, and properties. A node can also be derived from a function. name: type: properties: - key: value","title":"Nodes"},{"location":"obligations/#function","text":"A function refers to a previously defined function that is supported by the Policy Machine Event Processing Point (EPP). A list of valid functions, as well as tutorial on how to add functions can be found here . Example function: name: args: - \"\" - function: A function has a name and a list of arguments. The arguments are a list of string values or other functions.","title":"function"},{"location":"obligations/#obligation","text":"There is one obligation per yaml file. An obligation can have zero or more rules. label: rules: label - A label to give the obligation. If one is not specified, then a random value will be used. rules - Contains a set of zero or more rules.","title":"Obligation"},{"location":"obligations/#rule","text":"label: event: response: label - A label to give the rule. If one is not specified a random value will be used. event - The event pattern for this rule. response - The response to the event.","title":"Rule"},{"location":"obligations/#event-pattern","text":"event: subject: policyClass: operations: target: The Event Pattern specifies an event involving the policy elements of the Policy Machine. An example is a user performing a read operation on an object. This is called an access event, which is the primary focus of obligations as described in the NGAC standard. An access event has four components: The subject, policy class, operations, and target. All of these are optional, but omitting them will have different consequences, which will be described in the sections below. While the Policy Machine focuses on access events, it is possible to extend the functionality of the Event Pattern to other events such as time. The section How to Extend the Event Pattern section provides a tutorial on how this is possible with the Policy Machine.","title":"Event Pattern"},{"location":"obligations/#subject","text":"subject: user: anyUser: process: The subject specification can be a user, any user, any user from a set of users and/or user attributes, or a process. If the subject is omitted than all events will match this component of an access event.","title":"Subject"},{"location":"obligations/#user","text":"A user is identified by it's name.","title":"user"},{"location":"obligations/#any_user","text":"anyUser: The any_user element accepts an array of strings representing user names. If the element is empty then any user will match.","title":"any_user"},{"location":"obligations/#process","text":"process: The process element accepts a number as a process ID. Example: anyUser: # any user ### anyUser: # u1 or u2 - \"u1\" - \"u2\" process: 12345","title":"process"},{"location":"obligations/#policy-class","text":"policyClass: anyOf: --- eachOf: The policy class specification can specify a particular policy class with a given name, any policy class, any policy class from a set, all policy classes from a set, or all policy classes. Only one of anyOf and eachOf are allowed. Example ### policyClass: # any policy class ### policyClass: # PC1 or PC2 anyOf: - \"PC1\" - \"PC2\" ### policyClass: # PC1 and PC2 eachOf: - \"PC1\" - \"PC2\"","title":"Policy Class"},{"location":"obligations/#operations","text":"operations: - \"op\" The operations specification is a string array of operation names. Any event that matches an element of the array will match the operations event pattern. Example: operations: - \"read\" - \"write\"","title":"Operations"},{"location":"obligations/#target","text":"The target of an event can be A specific policy element policyElements: - name: name type: type Any policy element policyElements: * Omitting policyElements will have the same effect Any policy element that is contained in other policy elements containers: - name: type: - name: type: Any policy element from a set of policy elements policyElements: - name: name type: type - name: name type: type If both policyElements and containers are omitted it will be \"any policyElement in any container\" If containers is present then it will be \"any policyElement in the containers\", regardless of if policyElements is present If policyElements is present its \"any policyElement from the list provided\"","title":"Target"},{"location":"obligations/#response","text":"A response is a series of conditional actions. A condition can also be applied to the response itself.","title":"Response"},{"location":"obligations/#condition","text":"A condition is a set of boolean expressions that if all evaluate to true, allow for a response or specific action to be executed. condition: - function: - function:","title":"Condition"},{"location":"obligations/#create-action","text":"You can create a set of rules a set of nodes","title":"Create Action"},{"location":"obligations/#rule_1","text":"create: - label: event: response:","title":"rule"},{"location":"obligations/#nodes_1","text":"Create a single node and assign it to an already existing node in the graph. An array of commands is accepted to create more than one node. Functions are not allowed here . create: - what: name: node1 type: UA where: name: container1 type: UA","title":"nodes"},{"location":"obligations/#assign-action","text":"assign: what: where: The what and where nodes. The node in what will be assigned to the node in where .","title":"Assign Action"},{"location":"obligations/#grant-action","text":"Associate the node in subject with the node in target . grant: subject: operations: target: subject a node that will be the subject of the association. operations is an array of operations to add to the association. target a node that will be the target of the association.","title":"Grant Action"},{"location":"obligations/#deny-action-prohibition","text":"Deny a subject a set of operations on a set of target attributes. The subject can be a function, a process, or a node. The operations are an array of string. The target of the deny can be the intersection of a set of containers. It can also be the complement of the logical evaluation of the containers. Each container is identified by a name and type (properties are optional). If more than one node matches the provided name and type all will be taken into account. It is possible to take the complement of an individual container using the complement element. A deny also has a label that can be used to reference it later (i.e. to delete). deny: label: # string subject: # priority goes 1. function, 2. process, 3. node function: --- process: --- name: type: properties: operations: - \"\" - \"\" target: complement: # true|false, default false intersection: # true|false, default false containers: - name: type: complement: # true|false, default false - function: complement: # true|false","title":"Deny Action (Prohibition)"},{"location":"obligations/#delete-action","text":"The delete action can delete: nodes assignments associations prohibitions (denies) rules delete: nodes: - name: type: assignments: - what: name: type: where: name: type: associations: - subject: target: prohibitions: - label: rules: - label:","title":"Delete Action"},{"location":"obligations/#fuction-as-action","text":"You can define a function as a direct action in the response. function: name: args:","title":"Fuction as Action"},{"location":"obligations/#functions","text":"There are two main types of functions: utility and administrative. Utility functions are functions which aid in writing and executing obligations. Administrative functions provide a convenient way of bundling several administrative commands together.","title":"Functions"},{"location":"obligations/#predefined-functions","text":"This is a list of functions that are built into the library. They are all utility functions.","title":"Predefined Functions"},{"location":"obligations/#child_of_assign","text":"","title":"child_of_assign"},{"location":"obligations/#description","text":"Return the node that is the child of the assignment that is the focus of the event.","title":"Description"},{"location":"obligations/#parameters","text":"None","title":"Parameters"},{"location":"obligations/#return","text":"Node","title":"Return"},{"location":"obligations/#event-requirements","text":"The event must assign , assign to , deassign or deassign from .","title":"Event Requirements"},{"location":"obligations/#example","text":"function: name: child_of_assign","title":"Example"},{"location":"obligations/#parent_of_assign","text":"","title":"parent_of_assign"},{"location":"obligations/#description_1","text":"Return the node that is the child of the assignment that is the focus of the event.","title":"Description"},{"location":"obligations/#parameters_1","text":"None","title":"Parameters"},{"location":"obligations/#return_1","text":"Node","title":"Return"},{"location":"obligations/#event-requirements_1","text":"The event must assign , assign to , deassign or deassign from .","title":"Event Requirements"},{"location":"obligations/#example_1","text":"function: name: child_of_assign","title":"Example"},{"location":"obligations/#create_node","text":"","title":"create_node"},{"location":"obligations/#description_2","text":"Create a new node and return it.","title":"Description"},{"location":"obligations/#parameters_2","text":"parentName: parentType: name: string type: string properties: function ( to_props )","title":"Parameters"},{"location":"obligations/#return_2","text":"Node","title":"Return"},{"location":"obligations/#event-requirements_2","text":"None","title":"Event Requirements"},{"location":"obligations/#example_2","text":"function: name: create_node args: - \"parentNode\" - \"OA\" - \"newNode\" - \"OA\" - function: name: to_props args: - \"key1=value1\" - \"key2=value2\"","title":"Example"},{"location":"obligations/#current_process","text":"","title":"current_process"},{"location":"obligations/#description_3","text":"Return the current process ID","title":"Description"},{"location":"obligations/#parameters_3","text":"None","title":"Parameters"},{"location":"obligations/#return_3","text":"long","title":"Return"},{"location":"obligations/#event-requirements_3","text":"None","title":"Event Requirements"},{"location":"obligations/#example_3","text":"function: name: current_process","title":"Example"},{"location":"obligations/#current_target","text":"","title":"current_target"},{"location":"obligations/#description_4","text":"Return the node that is the target of the event being processed","title":"Description"},{"location":"obligations/#parameters_4","text":"None","title":"Parameters"},{"location":"obligations/#return_4","text":"Node","title":"Return"},{"location":"obligations/#event-requirements_4","text":"None","title":"Event Requirements"},{"location":"obligations/#example_4","text":"function: name: current_target","title":"Example"},{"location":"obligations/#current_user","text":"","title":"current_user"},{"location":"obligations/#description_5","text":"Return the user that triggered the event being processed","title":"Description"},{"location":"obligations/#parameters_5","text":"None","title":"Parameters"},{"location":"obligations/#return_5","text":"Node","title":"Return"},{"location":"obligations/#event-requirements_5","text":"None","title":"Event Requirements"},{"location":"obligations/#example_5","text":"function: name: current_user","title":"Example"},{"location":"obligations/#current_user_to_deny_subject","text":"","title":"current_user_to_deny_subject"},{"location":"obligations/#description_6","text":"Return a Prohibition.Subject with the current user.","title":"Description"},{"location":"obligations/#parameters_6","text":"None","title":"Parameters"},{"location":"obligations/#return_6","text":"Prohibition.Subject","title":"Return"},{"location":"obligations/#event-requirements_6","text":"None","title":"Event Requirements"},{"location":"obligations/#example_6","text":"function: name: current_user_to_deny_subject","title":"Example"},{"location":"obligations/#get_children","text":"","title":"get_children"},{"location":"obligations/#description_7","text":"Returns the children of a node.","title":"Description"},{"location":"obligations/#parameters_7","text":"name: string type: string properties: function ( to_props )","title":"Parameters"},{"location":"obligations/#return_7","text":"List<Node>","title":"Return"},{"location":"obligations/#event-requirements_7","text":"None","title":"Event Requirements"},{"location":"obligations/#example_7","text":"function: name: get_children args: - \"oa1\" - \"OA\" - function: name: to_props args: - \"key=value\"","title":"Example"},{"location":"obligations/#get_node","text":"","title":"get_node"},{"location":"obligations/#description_8","text":"Returns the node that matches the given name, type, and properties.","title":"Description"},{"location":"obligations/#parameters_8","text":"name: string type: string properties: function ( to_props )","title":"Parameters"},{"location":"obligations/#return_8","text":"Node","title":"Return"},{"location":"obligations/#event-requirements_8","text":"None","title":"Event Requirements"},{"location":"obligations/#example_8","text":"function: name: get_node args: - \"oa1\" - \"OA\" - function: name: to_props args: - \"key=value\"","title":"Example"},{"location":"obligations/#get_node_name","text":"","title":"get_node_name"},{"location":"obligations/#description_9","text":"Returns the name of the node that is returned by the function passed as the parameter.","title":"Description"},{"location":"obligations/#parameters_9","text":"node: function","title":"Parameters"},{"location":"obligations/#return_9","text":"String","title":"Return"},{"location":"obligations/#event-requirements_9","text":"None","title":"Event Requirements"},{"location":"obligations/#example_9","text":"function: name: get_node_name args: - function: name: current_target","title":"Example"},{"location":"obligations/#is_node_contained_in","text":"","title":"is_node_contained_in"},{"location":"obligations/#description_10","text":"Returns true if the node passed as the first parameter is assigned to the node passed as the second parameter. Both parameters are expected to be functions.","title":"Description"},{"location":"obligations/#parameters_10","text":"child: function parent: funtion","title":"Parameters"},{"location":"obligations/#return_10","text":"boolean","title":"Return"},{"location":"obligations/#event-requirements_10","text":"None","title":"Event Requirements"},{"location":"obligations/#example_10","text":"function: name: is_node_contained_in args: - function: name: get_node args: - \"oa1\" - \"OA\" - function: name: get_node args: - \"oa1\" - \"OA\"","title":"Example"},{"location":"obligations/#to_props","text":"","title":"to_props"},{"location":"obligations/#description_11","text":"Converts an array of strings with the format = to a Map .","title":"Description"},{"location":"obligations/#parameters_11","text":"strings: array","title":"Parameters"},{"location":"obligations/#return_11","text":"Map<String, String>","title":"Return"},{"location":"obligations/#event-requirements_11","text":"None","title":"Event Requirements"},{"location":"obligations/#example_11","text":"function: name: to_props args: - \"key1=value1\" - \"key2=value2\"","title":"Example"},{"location":"obligations/#custom-functions","text":"To create your own function follow the pattern used in the gov.nist.csd.pm.epp.functions package.","title":"Custom Functions"},{"location":"obligations/#1-implement-functionexecutor-interface","text":"Create a class that implements the gov.nist.csd.pm.epp.functions.FunctionExecutor interface. /** * The name of the function * @return the name of the function. */ String getFunctionName(); /** * How many parameters are expected. * @return the number of parameters this function expects */ int numParams(); /** * Execute the function. * @param eventCtx The event that is being processed * @param userID The ID of the user that triggered the event * @param processID The ID of the process that triggered the event * @param pdp The PDP to access the underlying policy data * @param function The function information * @param functionEvaluator A FunctionEvaluator to evaluate a nested functions * @return The object that the function is expected to return * @throws PMException If there is any error executing the function */ Object exec(EventContext eventCtx, long userID, long processID, PDP pdp, Function function, FunctionEvaluator functionEvaluator) throws PMException;","title":"1. Implement FunctionExecutor Interface"},{"location":"obligations/#2-provide-the-epp-with-the-function-executor","text":"To make your custom function available to the EPP, use this EPP constructor: public EPP(PDP pdp, FunctionExecutor ... executors) throws PMException { ... } Any executors that are provided to this constructor will be available to the EPP when processing events.","title":"2. Provide the EPP with the Function Executor"},{"location":"obligations/#pdp-events","text":"The following events are triggered by the PDP: Assign Assign to Deassign Deassign From For each call to assign() and deassign() in the PDP, there are two events. The child is being assigned/deassigned and the parent is being assigned to/deassigned from. These are only the built in events. Also, the PDP is not the only component that can trigger an event. The PEP is also capable of triggering events of any kind. This is where custom events can be triggered.","title":"PDP Events"},{"location":"reps/","text":"Representative Attributes Problem The nature of associations in NGAC means the operations provided in the association is inherited for all nodes that descend from the target of the association. This complicates creating policies with administrative permissions (assign, deassign, etc.) because there is no direct way to express the policy \"users in ua1 can assign to oa1\" and have that not affect any attributes that are assigned to it (i.e. if a user assigns oa2 to oa1, that user automatically inherits the assign to permission on oa2 as well) Solution Use Object Attributes that represent a target of the association and associate directly with that. Any access requests on the representee will also include any associations with it's target attribute.","title":"Representative Attributes"},{"location":"reps/#representative-attributes","text":"","title":"Representative Attributes"},{"location":"reps/#problem","text":"The nature of associations in NGAC means the operations provided in the association is inherited for all nodes that descend from the target of the association. This complicates creating policies with administrative permissions (assign, deassign, etc.) because there is no direct way to express the policy \"users in ua1 can assign to oa1\" and have that not affect any attributes that are assigned to it (i.e. if a user assigns oa2 to oa1, that user automatically inherits the assign to permission on oa2 as well)","title":"Problem"},{"location":"reps/#solution","text":"Use Object Attributes that represent a target of the association and associate directly with that. Any access requests on the representee will also include any associations with it's target attribute.","title":"Solution"},{"location":"usage/","text":"","title":"Usage"}]}